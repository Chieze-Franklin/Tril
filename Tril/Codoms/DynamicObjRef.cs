using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Mono.Cecil;

using Tril.Attributes;
using Tril.Delegates;
using Tril.Models;

namespace Tril.Codoms
{
    /// <summary>
    /// Represents a statement that references an __arglist object that was dynamically created.
    /// </summary>
    [Serializable]
    public sealed class DynamicArglist : Tril.Codoms.DynamicObjRef
    {
        /// <summary>
        /// Creates a new instance of Tril.Codoms.DynamicArglistObjRef
        /// </summary>
        public DynamicArglist()
            : base("__arglist", DynamicArglist.kind.GetLongName(), DynamicArglist.kind)
        { }

        static Kind kind = Kind.GetCachedKind(Type.GetType("System.RuntimeArgumentHandle").ToTypeDefinition(true));

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            DynamicArglist clone = new DynamicArglist();
            clone = (DynamicArglist)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                    return "__arglist /* use \"new System.RuntimeArgumentHandle()\" in languages that do not know what \"__arglist\" is */";
                return "__arglist; /* use \"new System.RuntimeArgumentHandle()\" in languages that do not know what \"__arglist\" is */";
            }
        }
    }

    /// <summary>
    /// Represents a statement that references an __makeref object that was dynamically created.
    /// </summary>
    [Serializable]
    public sealed class DynamicMakeRef : Tril.Codoms.DynamicObjRef
    {
        ValueStatement _ptr;

        /// <summary>
        /// Creates a new instance of Tril.Codoms.DynamicMakeRefObjRef
        /// </summary>
        /// <param name="pointer"></param>
        public DynamicMakeRef(ValueStatement pointer)
            : base("__makeref", DynamicMakeRef.kind.GetLongName(), DynamicMakeRef.kind)
        {
            if (pointer == null)
                throw new NullReferenceException(this.GetType().FullName + ": Pointer cannot be null!");
            _ptr = pointer;
            _ptr.IsInline = true;
            _ptr.ShowOuterBrackets = false;
            this.Label = _ptr.Label;
        }

        static Kind kind = Kind.GetCachedKind(Type.GetType("System.TypedReference").ToTypeDefinition(true));

        /// <summary>
        /// Gets the pointer object
        /// </summary>
        public ValueStatement Pointer 
        {
            get { return _ptr; }
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            DynamicMakeRef clone = new DynamicMakeRef(Pointer);
            clone = (DynamicMakeRef)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                    return "__makeref(" + Pointer.ToString(translator) + ") /* use \"System.TypedReference.MakeTypedReference(...)\" in languages that do not know what \"__makeref\" is */";
                return "__makeref(" + Pointer.ToString(translator) + "); /* use \"System.TypedReference.MakeTypedReference(...)\" in languages that do not know what \"__makeref\" is */";
            }
        }
    }

    /// <summary>
    /// Represents a statement that references an __reftype object that was dynamically created.
    /// </summary>
    [Serializable]
    public sealed class DynamicRefType : Tril.Codoms.DynamicObjRef
    {
        ValueStatement _tr;

        /// <summary>
        /// Creates a new instance of Tril.Codoms.DynamicRefType
        /// </summary>
        /// <param name="typedRef"></param>
        public DynamicRefType(ValueStatement typedRef)
            : base("__reftype", DynamicRefType.kind.GetLongName(), DynamicRefType.kind)
        {
            if (typedRef == null)
                throw new NullReferenceException(this.GetType().FullName + ": Typed reference cannot be null!");
            _tr = typedRef;
            _tr.IsInline = true;
            _tr.ShowOuterBrackets = false;
            this.Label = _tr.Label;
        }

        static Kind kind = Kind.GetCachedKind(Type.GetType("System.RuntimeTypeHandle").ToTypeDefinition(true));

        /// <summary>
        /// Gets the pointer object
        /// </summary>
        public ValueStatement TypedReference
        {
            get { return _tr; }
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            DynamicRefType clone = new DynamicRefType(TypedReference);
            clone = (DynamicRefType)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                    return "__reftype(" + TypedReference.ToString(translator) + ") /* use \"System.TypedReference.TargetTypeToken(...)\" in languages that do not know what \"__reftype\" is */";
                return "__reftype(" + TypedReference.ToString(translator) + "); /* use \"System.TypedReference.TargetTypeToken(...)\" in languages that do not know what \"__reftype\" is */";
            }
        }
    }

    /// <summary>
    /// Represents a statement that references an __refvalue object that was dynamically created.
    /// </summary>
    [Serializable]
    public sealed class DynamicRefValue : Tril.Codoms.DynamicObjRef
    {
        ValueStatement _tr;
        Kind _tgtKind;
        string _cachedTgtKind;

        /// <summary>
        /// Creates a new instance of Tril.Codoms.DynamicRefValue
        /// </summary>
        /// <param name="typedRef"></param>
        /// <param name="targetKind"></param>
        /// <param name="cachedTargetKind"></param>
        public DynamicRefValue(ValueStatement typedRef, Kind targetKind, string cachedTargetKind)
            : base("__refvalue", targetKind.GetLongName(), targetKind)
        {
            if (typedRef == null)
                throw new NullReferenceException(this.GetType().FullName + ": Typed reference cannot be null!");
            if (targetKind == null)
                throw new NullReferenceException(this.GetType().FullName + ": Target Kind cannot be null!");
            if (cachedTargetKind == null || cachedTargetKind.Trim() == "")
                throw new NullReferenceException(this.GetType().FullName + ": Cached name target Kind cannot be null or empty!");

            _tr = typedRef;
            _tr.IsInline = true;
            _tr.ShowOuterBrackets = false;
            this.Label = _tr.Label;

            _tgtKind = targetKind;
            _cachedTgtKind = cachedTargetKind;
        }

        /// <summary>
        /// Gets the cached name of the target kind
        /// </summary>
        public string CachedTargetKind
        {
            get { return _cachedTgtKind; }
        }
        /// <summary>
        /// Gets the target kind
        /// </summary>
        public Kind TargetKind
        {
            get { return _tgtKind; }
        }
        /// <summary>
        /// Gets the pointer object
        /// </summary>
        public ValueStatement TypedReference
        {
            get { return _tr; }
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            DynamicRefValue clone = new DynamicRefValue(TypedReference, TargetKind, CachedTargetKind);
            clone = (DynamicRefValue)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                    return "__refvalue(" + TypedReference.ToString(translator) + ", " + CachedTargetKind + ") /* use \"System.TypedReference.ToObject(...)\" in languages that do not know what \"__refvalue\" is */";
                return "__refvalue(" + TypedReference.ToString(translator) + ", " + CachedTargetKind + "); /* use \"System.TypedReference.ToObject(...)\" in languages that do not know what \"__refvalue\" is */";
            }
        }
    }
}
