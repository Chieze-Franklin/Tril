using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Mono.Cecil;

using Tril.Attributes;
using Tril.Delegates;
using Tril.Models;

namespace Tril.Codoms
{
    /// <summary>
    /// Represents an addition operation
    /// </summary>
    [Serializable]
    public sealed class Add : BinaryArithmeticOperation
    {
        /// <summary>
        /// Creates a new instance of Tril.Codoms.Add
        /// </summary>
        /// <param name="first"></param>
        /// <param name="second"></param>
        public Add(ValueStatement first, ValueStatement second)
            : base(first, second)
        {
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            Add clone = new Add(FirstOperand, SecondOperand);
            clone = (Add)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            //return the larger type
            Kind firstKind = FirstOperand.GetKind();
            Kind secondKind = SecondOperand.GetKind();
            TypeReference first = firstKind.UnderlyingType;
            TypeReference second = secondKind.UnderlyingType;

            //if (first.IsPointer && second.IsPointer) //should not occur in a valid CIL
            //{
            //    if (nativeIntDef == null)
            //        nativeIntDef = new IntPtr(new int()).GetType().ToTypeDefinition(true);
            //    return Kind.GetCachedKind(nativeIntDef); //a native int 
            //}

            //else 
                if (first.FullName == second.FullName)
                return firstKind;

            else if (first.IsPointer)// && !second.IsPointer)
                return firstKind;
            else if (second.IsPointer)// && !first.IsPointer)
                return secondKind;

            else if (firstKind.IsNativeInt)
                return firstKind;
            else if (secondKind.IsNativeInt)
                return secondKind;

            return firstKind;
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                    return (ShowOuterBrackets ? "(" : "") + FirstOperand.ToString(translator) + " + " + SecondOperand.ToString(translator) + (ShowOuterBrackets ? ")" : "");
                return FirstOperand.ToString(translator) + " + " + SecondOperand.ToString(translator) + ";";
            }
        }
    }

    /// <summary>
    /// Represents a bitwise AND operation
    /// </summary>
    [Serializable]
    public sealed class BitAnd : BinaryArithmeticOperation
    {
        /// <summary>
        /// Creates a new instance of Tril.Codoms.BitAnd
        /// </summary>
        /// <param name="first"></param>
        /// <param name="second"></param>
        public BitAnd(ValueStatement first, ValueStatement second)
            : base(first, second)
        {
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            BitAnd clone = new BitAnd(FirstOperand, SecondOperand);
            clone = (BitAnd)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            Kind firstKind = FirstOperand.GetKind();
            Kind secondKind = SecondOperand.GetKind();

            if (firstKind.IsNativeInt)
                return firstKind;
            else if (secondKind.IsNativeInt)
                return secondKind;

            return firstKind;
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                    return (ShowOuterBrackets ? "(" : "") + FirstOperand.ToString(translator) + " & " + SecondOperand.ToString(translator) + (ShowOuterBrackets ? ")" : "");
                return FirstOperand.ToString(translator) + " & " + SecondOperand.ToString(translator) + ";";
            }
        }
    }

    /// <summary>
    /// Represents a bitwise OR operation
    /// </summary>
    [Serializable]
    public sealed class BitOr : BinaryArithmeticOperation
    {
        /// <summary>
        /// Creates a new instance of Tril.Codoms.BitOr
        /// </summary>
        /// <param name="first"></param>
        /// <param name="second"></param>
        public BitOr(ValueStatement first, ValueStatement second)
            : base(first, second)
        {
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            BitOr clone = new BitOr(FirstOperand, SecondOperand);
            clone = (BitOr)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            Kind firstKind = FirstOperand.GetKind();
            Kind secondKind = SecondOperand.GetKind();

            if (firstKind.IsNativeInt)
                return firstKind;
            else if (secondKind.IsNativeInt)
                return secondKind;

            return firstKind;
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                    return (ShowOuterBrackets ? "(" : "") + FirstOperand.ToString(translator) + " | " + SecondOperand.ToString(translator) + (ShowOuterBrackets ? ")" : "");
                return FirstOperand.ToString(translator) + " | " + SecondOperand.ToString(translator) + ";";
            }
        }
    }

    /// <summary>
    /// Represents a bitwise XOR operation
    /// </summary>
    [Serializable]
    public sealed class BitXor : BinaryArithmeticOperation
    {
        /// <summary>
        /// Creates a new instance of Tril.Codoms.BitXor
        /// </summary>
        /// <param name="first"></param>
        /// <param name="second"></param>
        public BitXor(ValueStatement first, ValueStatement second)
            : base(first, second)
        {
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            BitXor clone = new BitXor(FirstOperand, SecondOperand);
            clone = (BitXor)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            Kind firstKind = FirstOperand.GetKind();
            Kind secondKind = SecondOperand.GetKind();

            if (firstKind.IsNativeInt)
                return firstKind;
            else if (secondKind.IsNativeInt)
                return secondKind;

            return firstKind;
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                    return (ShowOuterBrackets ? "(" : "") + FirstOperand.ToString(translator) + " ^ " + SecondOperand.ToString(translator) + (ShowOuterBrackets ? ")" : "");
                return FirstOperand.ToString(translator) + " ^ " + SecondOperand.ToString(translator) + ";";
            }
        }
    }

    /// <summary>
    /// Represents a division operation
    /// </summary>
    [Serializable]
    public sealed class Div : BinaryArithmeticOperation
    {
        /// <summary>
        /// Creates a new instance of Tril.Codoms.Div
        /// </summary>
        /// <param name="first"></param>
        /// <param name="second"></param>
        public Div(ValueStatement first, ValueStatement second)
            : base(first, second)
        {
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            Div clone = new Div(FirstOperand, SecondOperand);
            clone = (Div)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            Kind firstKind = FirstOperand.GetKind();
            Kind secondKind = SecondOperand.GetKind();

            if (firstKind.IsNativeInt)
                return firstKind;
            else if (secondKind.IsNativeInt)
                return secondKind;

            return firstKind;
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                    return (ShowOuterBrackets ? "(" : "") + FirstOperand.ToString(translator) + " / " + SecondOperand.ToString(translator) + (ShowOuterBrackets ? ")" : "");
                return FirstOperand.ToString(translator) + " / " + SecondOperand.ToString(translator) + ";";
            }
        }
    }

    /// <summary>
    /// Represents an integer division operation; a division whose result is always a whole number
    /// </summary>
    [Serializable]
    public sealed class IntDiv : BinaryArithmeticOperation
    {
        /// <summary>
        /// Creates a new instance of Tril.Codoms.IDiv
        /// </summary>
        /// <param name="first"></param>
        /// <param name="second"></param>
        public IntDiv(ValueStatement first, ValueStatement second)
            : base(first, second)
        {
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            IntDiv clone = new IntDiv(FirstOperand, SecondOperand);
            clone = (IntDiv)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            if (intDef == null)
                init_intDef();
            return Kind.GetCachedKind(intDef);
        }
        /// <summary>
        /// gets the VB.NET representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                    return (ShowOuterBrackets ? "(" : "") + FirstOperand.ToString(translator) + " \\ " + SecondOperand.ToString(translator) + (ShowOuterBrackets ? ")" : "");
                return FirstOperand.ToString(translator) + " \\ " + SecondOperand.ToString(translator) + ";";
            }
        }
    }

    /// <summary>
    /// Represents a multiplication operation.
    /// </summary>
    [Serializable]
    public sealed class Mul : BinaryArithmeticOperation
    {
        /// <summary>
        /// Creates a new instance of Tril.Codoms.Mul
        /// </summary>
        /// <param name="first"></param>
        /// <param name="second"></param>
        public Mul(ValueStatement first, ValueStatement second)
            : base(first, second)
        {
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            Mul clone = new Mul(FirstOperand, SecondOperand);
            clone = (Mul)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            Kind firstKind = FirstOperand.GetKind();
            Kind secondKind = SecondOperand.GetKind();

            if (firstKind.IsNativeInt)
                return firstKind;
            else if (secondKind.IsNativeInt)
                return secondKind;

            return firstKind;
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                    return (ShowOuterBrackets ? "(" : "") + FirstOperand.ToString(translator) + " * " + SecondOperand.ToString(translator) + (ShowOuterBrackets ? ")" : "");
                return FirstOperand.ToString(translator) + " * " + SecondOperand.ToString(translator) + ";";
            }
        }
    }

    /// <summary>
    /// Represents a modulus operation
    /// </summary>
    [Serializable]
    public sealed class Rem : BinaryArithmeticOperation
    {
        /// <summary>
        /// Creates a new instance of Tril.Codoms.Rem
        /// </summary>
        /// <param name="first"></param>
        /// <param name="second"></param>
        public Rem(ValueStatement first, ValueStatement second)
            : base(first, second)
        {
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            Rem clone = new Rem(FirstOperand, SecondOperand);
            clone = (Rem)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            Kind firstKind = FirstOperand.GetKind();
            Kind secondKind = SecondOperand.GetKind();

            if (firstKind.IsNativeInt)
                return firstKind;
            else if (secondKind.IsNativeInt)
                return secondKind;

            return firstKind;
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                    return (ShowOuterBrackets ? "(" : "") + FirstOperand.ToString(translator) + " % " + SecondOperand.ToString(translator) + (ShowOuterBrackets ? ")" : "");
                return FirstOperand.ToString(translator) + " % " + SecondOperand.ToString(translator) + ";";
            }
        }
    }

    /// <summary>
    /// Represents a left shift operation
    /// </summary>
    [Serializable]
    public sealed class ShiftLeft : BinaryArithmeticOperation
    {
        /// <summary>
        /// Creates a new instance of Tril.Codoms.LeftShift
        /// </summary>
        /// <param name="first"></param>
        /// <param name="second"></param>
        public ShiftLeft(ValueStatement first, ValueStatement second)
            : base(first, second)
        {
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            ShiftLeft clone = new ShiftLeft(FirstOperand, SecondOperand);
            clone = (ShiftLeft)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            return FirstOperand.GetKind();
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                    return (ShowOuterBrackets ? "(" : "") + FirstOperand.ToString(translator) + " << " + SecondOperand.ToString(translator) + (ShowOuterBrackets ? ")" : "");
                return FirstOperand.ToString(translator) + " << " + SecondOperand.ToString(translator) + ";";
            }
        }
    }

    /// <summary>
    /// Represents a right shift operation
    /// </summary>
    [Serializable]
    public sealed class ShiftRight : BinaryArithmeticOperation
    {
        bool _unsigned = false;

        /// <summary>
        /// Creates a new instance of Tril.Codoms.RightShift
        /// </summary>
        /// <param name="first"></param>
        /// <param name="second"></param>
        public ShiftRight(ValueStatement first, ValueStatement second, bool unsigned)
            : base(first, second)
        {
            this._unsigned = unsigned;
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            ShiftRight clone = new ShiftRight(FirstOperand, SecondOperand, IsUnsigned);
            clone = (ShiftRight)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            return FirstOperand.GetKind();
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                    return (ShowOuterBrackets ? "(" : "") + FirstOperand.ToString(translator) + " >> " + SecondOperand.ToString(translator) + (ShowOuterBrackets ? ")" : "");
                return FirstOperand.ToString(translator) + " >> " + SecondOperand.ToString(translator) + ";";
            }
        }
        public bool IsUnsigned 
        {
            get { return _unsigned; }
        }
    }

    /// <summary>
    /// Represents an subtraction operation
    /// </summary>
    [Serializable]
    public sealed class Sub : BinaryArithmeticOperation
    {
        /// <summary>
        /// Creates a new instance of Tril.Codoms.Sub
        /// </summary>
        /// <param name="first"></param>
        /// <param name="second"></param>
        public Sub(ValueStatement first, ValueStatement second)
            : base(first, second)
        {
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            Sub clone = new Sub(FirstOperand, SecondOperand);
            clone = (Sub)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            //return the larger type
            //if the two are pointers, return a native int
            Kind firstKind = FirstOperand.GetKind();
            Kind secondKind = SecondOperand.GetKind();
            TypeReference first = firstKind.UnderlyingType;
            TypeReference second = secondKind.UnderlyingType;

            if (first.IsPointer && second.IsPointer)
            {
                if (nativeIntDef == null)
                    init_nativeIntDef();
                return Kind.GetCachedKind(nativeIntDef); //a native int 
            }

            else if (first.FullName == second.FullName)
                return firstKind;

            else if (first.IsPointer)// && !second.IsPointer)
                return firstKind;
            else if (second.IsPointer)// && !first.IsPointer)
                return secondKind;

            else if (firstKind.IsNativeInt)
                return firstKind;
            else if (secondKind.IsNativeInt)
                return secondKind;

            return firstKind;
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                    return (ShowOuterBrackets ? "(" : "") + FirstOperand.ToString(translator) + " - " + SecondOperand.ToString(translator) + (ShowOuterBrackets ? ")" : "");
                return FirstOperand.ToString(translator) + " - " + SecondOperand.ToString(translator) + ";";
            }
        }
    }

    /// <summary>
    /// Represents an unsigned division operation
    /// </summary>
    [Serializable]
    public sealed class UDiv : BinaryArithmeticOperation
    {
        /// <summary>
        /// Creates a new instance of Tril.Codoms.UDiv
        /// </summary>
        /// <param name="first"></param>
        /// <param name="second"></param>
        public UDiv(ValueStatement first, ValueStatement second)
            : base(first, second)
        {
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            UDiv clone = new UDiv(FirstOperand, SecondOperand);
            clone = (UDiv)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            Kind firstKind = FirstOperand.GetKind();
            Kind secondKind = SecondOperand.GetKind();

            if (firstKind.IsNativeInt)
                return firstKind;
            else if (secondKind.IsNativeInt)
                return secondKind;

            return firstKind;
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                    return (ShowOuterBrackets ? "(" : "") + FirstOperand.ToString(translator) + " / " + SecondOperand.ToString(translator) + (ShowOuterBrackets ? ")" : "");
                return FirstOperand.ToString(translator) + " / " + SecondOperand.ToString(translator) + ";";
            }
        }
    }

    /// <summary>
    /// Represents an unsigned modulus operation
    /// </summary>
    [Serializable]
    public sealed class URem : BinaryArithmeticOperation
    {
        /// <summary>
        /// Creates a new instance of Tril.Codoms.URem
        /// </summary>
        /// <param name="first"></param>
        /// <param name="second"></param>
        public URem(ValueStatement first, ValueStatement second)
            : base(first, second)
        {
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            URem clone = new URem(FirstOperand, SecondOperand);
            clone = (URem)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            Kind firstKind = FirstOperand.GetKind();
            Kind secondKind = SecondOperand.GetKind();

            if (firstKind.IsNativeInt)
                return firstKind;
            else if (secondKind.IsNativeInt)
                return secondKind;

            return firstKind;
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                    return (ShowOuterBrackets ? "(" : "") + FirstOperand.ToString(translator) + " % " + SecondOperand.ToString(translator) + (ShowOuterBrackets ? ")" : "");
                return FirstOperand.ToString(translator) + " % " + SecondOperand.ToString(translator) + ";";
            }
        }
    }
}
