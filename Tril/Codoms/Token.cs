using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using Tril.Attributes;
using Tril.Delegates;
using Tril.Models;

namespace Tril.Codoms
{
    /// <summary>
    /// Represents a token
    /// </summary>
    [Serializable]
    public abstract class Token : ReferenceStatement
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="cachedName"></param>
        /// <param name="cachedDeclaringKind"></param>
        public Token(string cachedName, string cachedDeclaringKind)
            : base(cachedName, cachedDeclaringKind) { }
    }

    /// <summary>
    /// Represents a field token
    /// </summary>
    [Serializable]
    public sealed class FieldToken : Token
    {
        Field _refedFld;

        /// <summary>
        /// Creates a new instance of Tril.Codoms.FieldToken
        /// </summary>
        /// <param name="cachedFieldName"></param>
        /// <param name="cachedDeclaringKind"></param>
        /// <param name="refedField"></param>
        public FieldToken(string cachedFieldName, string cachedDeclaringKind, Field refedField)
            : base(cachedFieldName, cachedDeclaringKind)
        {
            if (refedField == null)
                throw new NullReferenceException(this.GetType().FullName + ": Referenced field cannot be null!");

            _refedFld = refedField;
        }

        /// <summary>
        /// Gets the referenced field.
        /// </summary>
        public Field ReferencedField
        {
            get { return _refedFld; }
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            FieldToken clone = new FieldToken(CachedName, CachedKind, ReferencedField);
            clone = (FieldToken)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            if (rtFldDef == null)
                init_rtFldDef();
            return Kind.GetCachedKind(rtFldDef);
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                {
                    if (UseShortName)
                        return CachedName;
                    return CachedKind + "." + CachedName;
                }
                if (UseShortName)
                    return CachedName + ";";
                return CachedKind + "." + CachedName + ";";
            }
        }
    }

    /// <summary>
    /// Represents a method token
    /// </summary>
    [Serializable]
    public sealed class MethodToken : Token
    {
        Method _refedMethod;

        /// <summary>
        /// Creates a new instance of Tril.Codoms.MethodToken
        /// </summary>
        /// <param name="cachedMethodName"></param>
        /// <param name="cachedDeclaringKind"></param>
        /// <param name="refedMethod"></param>
        public MethodToken(string cachedMethodName, string cachedDeclaringKind, Method refedMethod)
            : base(cachedMethodName, cachedDeclaringKind)
        {
            if (refedMethod == null)
                throw new NullReferenceException(this.GetType().FullName + ": Referenced method cannot be null!");

            _refedMethod = refedMethod;
        }

        /// <summary>
        /// Gets the referenced method.
        /// </summary>
        public Method ReferencedMethod
        {
            get { return _refedMethod; }
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            MethodToken clone = new MethodToken(CachedName, CachedKind, ReferencedMethod);
            clone = (MethodToken)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            if (rtMtdDef == null)
                init_rtMtdDef();
            return Kind.GetCachedKind(rtMtdDef);
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                {
                    if (UseShortName)
                        return CachedName;
                    return CachedKind + "." + CachedName;
                }
                if (UseShortName)
                    return CachedName + ";";
                return CachedKind + "." + CachedName + ";";
            }
        }
    }

    /// <summary>
    /// Represents a type token
    /// </summary>
    [Serializable]
    public sealed class TypeToken : Token
    {
        Kind _refedKind;

        /// <summary>
        /// Creates a new instance of Tril.Codoms.TypeToken
        /// </summary>
        /// <param name="cachedTypeName"></param>
        /// <param name="cachedDeclaringKind"></param>
        /// <param name="refedKind"></param>
        public TypeToken(string cachedTypeName, string cachedDeclaringKind, Kind refedKind)
            : base(cachedTypeName, cachedDeclaringKind)
        {
            if (refedKind == null)
                throw new NullReferenceException(this.GetType().FullName + ": Referenced kind cannot be null!");

            _refedKind = refedKind;
        }

        /// <summary>
        /// Gets the referenced kind.
        /// </summary>
        public Kind ReferencedKind
        {
            get { return _refedKind; }
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            TypeToken clone = new TypeToken(CachedName, CachedKind, ReferencedKind);
            clone = (TypeToken)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            if (rtTypDef == null)
                init_rtTypDef();
            return Kind.GetCachedKind(rtTypDef);
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                {
                    return CachedName;
                }
                return CachedName + ";";
            }
        }
    }
}
