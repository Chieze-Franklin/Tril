using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using Tril.Attributes;
using Tril.Delegates;
using Tril.Models;

namespace Tril.Codoms
{
    /// <summary>
    /// Represents a constant value
    /// </summary>
    [Serializable]
    public abstract class Constant : ValueStatement
    {
        /// <summary>
        /// Creates a new instance of Tril.Constant.
        /// Constants are inline by default.
        /// </summary>
        public Constant()
        {
            IsInline = true;
        }
    }

    /// <summary>
    /// The base class for all numerical constants
    /// </summary>
    [Serializable]
    public abstract class NumberConstant<T> : Constant, INegatable where T : struct
    {
        T _val;

        /// <summary>
        /// Creates a new instance of Tril.Codoms.NumberConstant
        /// </summary>
        /// <param name="value"></param>
        public NumberConstant(T value)
        {
            _val = value;
        }

        /// <summary>
        /// Gets the value of this constant
        /// </summary>
        public T Value
        {
            get { return _val; }
        }

        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            return Kind.GetCachedKind(Value.GetType().ToTypeDefinition(true));
        }
        /// <summary>
        /// Negates the statement
        /// </summary>
        public void Negate()
        {
            if (_val is int)
            {
                _val = (T)(object)(Convert.ToInt32(_val.ToString()) * -1);
            }
            else if (_val is uint)
            {
                _val = (T)(object)(Convert.ToUInt32(_val.ToString()) * -1);
            }
            else if (_val is long)
            {
                _val = (T)(object)(Convert.ToInt64(_val.ToString()) * -1);
            }
            else if (_val is ulong)
            {
                _val = (T)(object)(Convert.ToUInt64(_val.ToString()) * Convert.ToUInt64(-1));
            }
            else if (_val is float)
            {
                _val = (T)(object)(Convert.ToSingle(_val.ToString()) * -1);
            }
            else if (_val is double)
            {
                _val = (T)(object)(Convert.ToDouble(_val.ToString()) * -1);
            }
            else
            {
                _val = (T)(object)(Convert.ToDecimal(_val.ToString()) * -1);
            }
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                return Value.ToString();
            }
        }
    }

    /// <summary>
    /// Represents a constant signed (positive and negative) int value
    /// </summary>
    [Serializable]
    public sealed class IntConst : NumberConstant<int>
    {
        /// <summary>
        /// Creates a new instance of Tril.Codoms.IntConst
        /// </summary>
        /// <param name="value"></param>
        public IntConst(int value)
            : base(value)
        {
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            IntConst clone = new IntConst(Value);
            clone = (IntConst)ValueStatement.Clone(this, clone);
            return clone;
        }
    }

    /// <summary>
    /// Represents a constant unsigned (positive only) integer value
    /// </summary>
    [Serializable]
    public sealed class UIntConst : NumberConstant<uint>
    {
        /// <summary>
        /// Creates a new instance of Tril.Codoms.UIntConst
        /// </summary>
        /// <param name="value"></param>
        public UIntConst(uint value)
            : base(value)
        {
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            UIntConst clone = new UIntConst(Value);
            clone = (UIntConst)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                return Value.ToString() + "U";
            }
        }
    }

    /// <summary>
    /// Represents a constant signed (positive and negative) long value
    /// </summary>
    [Serializable]
    public sealed class LongConst : NumberConstant<long>
    {
        /// <summary>
        /// Creates a new instance of Tril.Codoms.LongConst
        /// </summary>
        /// <param name="value"></param>
        public LongConst(long value)
            : base(value)
        {
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            LongConst clone = new LongConst(Value);
            clone = (LongConst)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                return Value.ToString() + "L";
            }
        }
    }

    /// <summary>
    /// Represents a constant unsigned (positive only) long value
    /// </summary>
    [Serializable]
    public sealed class ULongConst : NumberConstant<ulong>
    {
        /// <summary>
        /// Creates a new instance of Tril.Codoms.ULongConst
        /// </summary>
        /// <param name="value"></param>
        public ULongConst(ulong value)
            : base(value)
        {
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            ULongConst clone = new ULongConst(Value);
            clone = (ULongConst)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                return Value.ToString() + "UL";
            }
        }
    }

    /// <summary>
    /// Represents a constant float (single) value
    /// </summary>
    [Serializable]
    public sealed class FloatConst : NumberConstant<float>
    {
        /// <summary>
        /// Creates a new instance of Tril.Codoms.FloatConst
        /// </summary>
        /// <param name="value"></param>
        public FloatConst(float value)
            : base(value)
        {
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            FloatConst clone = new FloatConst(Value);
            clone = (FloatConst)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                return Value.ToString() + "F";
            }
        }
    }

    /// <summary>
    /// Represents a constant double value
    /// </summary>
    [Serializable]
    public sealed class DoubleConst : NumberConstant<double>
    {
        /// <summary>
        /// Creates a new instance of Tril.Codoms.DoubleConst
        /// </summary>
        /// <param name="value"></param>
        public DoubleConst(double value)
            : base(value)
        {
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            DoubleConst clone = new DoubleConst(Value);
            clone = (DoubleConst)ValueStatement.Clone(this, clone);
            return clone;
        }
    }

    /// <summary>
    /// Represents a constant floating point value
    /// </summary>
    [Serializable]
    public sealed class FloatingPointConst : NumberConstant<double>
    {
        /// <summary>
        /// Creates a new instance of Tril.Codoms.FloatingPointConst
        /// </summary>
        /// <param name="value"></param>
        public FloatingPointConst(double value)
            : base(value)
        {
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            FloatingPointConst clone = new FloatingPointConst(Value);
            clone = (FloatingPointConst)ValueStatement.Clone(this, clone);
            return clone;
        }
    }

    /// <summary>
    /// Represents a constant decimal value
    /// </summary>
    [Serializable]
    public sealed class DecimalConst : NumberConstant<decimal>
    {
        /// <summary>
        /// Creates a new instance of Tril.Codoms.DecimalConst
        /// </summary>
        /// <param name="value"></param>
        public DecimalConst(decimal value)
            : base(value)
        {
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            DecimalConst clone = new DecimalConst(Value);
            clone = (DecimalConst)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                return Value.ToString() + "M";
            }
        }
    }

    /// <summary>
    /// Represents a constant bool value
    /// </summary>
    [Serializable]
    public sealed class BoolConst : Constant
    {
        bool _bool;

        /// <summary>
        /// Creates a new instance of Tril.Codoms.BoolConst
        /// </summary>
        /// <param name="boolean"></param>
        public BoolConst(bool boolean)
        {
            _bool = boolean;
        }

        /// <summary>
        /// Gets the value of this constant
        /// </summary>
        public bool Value
        {
            get { return _bool; }
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            BoolConst clone = new BoolConst(Value);
            clone = (BoolConst)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            if (boolDef == null)
                init_boolDef();
            return Kind.GetCachedKind(boolDef);
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                return Value.ToString().ToLower();
            }
        }
    }

    /// <summary>
    /// Represents a constant char value
    /// </summary>
    [Serializable]
    public sealed class CharConst : Constant
    {
        char _char;

        /// <summary>
        /// Creates a new instance of Tril.Codoms.CharConst
        /// </summary>
        /// <param name="Char"></param>
        public CharConst(char Char)
        {
            _char = Char;
        }

        /// <summary>
        /// Gets the value of this constant
        /// </summary>
        public char Value
        {
            get { return _char; }
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            CharConst clone = new CharConst(Value);
            clone = (CharConst)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            if (charDef == null)
                init_charDef();
            return Kind.GetCachedKind(charDef);
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                string rawString = Value.ToString();
                rawString = rawString.Replace("\\", "\\\\").Replace("\"", "\\\"").Replace("\'", "\\\'")
                    .Replace("\0", "\\0").Replace("\a", "\\a").Replace("\b", "\\b").Replace("\f", "\\f")
                    .Replace("\n", "\\n").Replace("\r", "\\r").Replace("\t", "\\t").Replace("\v", "\\v");//.Replace("\x", "\\x");

                return "'" + rawString + "'";
            }
        }
    }

    /// <summary>
    /// Represents a constant string value
    /// </summary>
    [Serializable]
    public sealed class StringConst : Constant
    {
        string _str;

        /// <summary>
        /// Creates a new instance of Tril.Codoms.StringConst
        /// </summary>
        /// <param name="String"></param>
        public StringConst(string String)
        {
            _str = String;
        }

        /// <summary>
        /// Gets the value of this constant
        /// </summary>
        public string Value
        {
            get { return _str; }
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            StringConst clone = new StringConst(Value);
            clone = (StringConst)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            if (strDef == null)
                init_strDef();
            return Kind.GetCachedKind(strDef);
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                string rawString = Value.ToString();
                rawString = rawString.Replace("\\", "\\\\").Replace("\"", "\\\"").Replace("\'", "\\\'")
                    .Replace("\0", "\\0").Replace("\a", "\\a").Replace("\b", "\\b").Replace("\f", "\\f")
                    .Replace("\n", "\\n").Replace("\r", "\\r").Replace("\t", "\\t").Replace("\v", "\\v");//.Replace("\x", "\\x");

                return "\"" + rawString + "\"";
            }
        }
    }

    /// <summary>
    /// Represents null
    /// </summary>
    [Serializable]
    public sealed class Null : Constant
    {
        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            Null clone = new Null();
            clone = (Null)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// Returns null for Tril.Null
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            return null;
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                return "null";
            }
        }
    }
}
