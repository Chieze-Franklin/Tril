using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Mono.Cecil;

using Tril.Attributes;
using Tril.Delegates;
using Tril.Models;

namespace Tril.Codoms
{
    /// <summary>
    /// Represents an "address of" operation.
    /// This is useful in languages that support pointers.
    /// </summary>
    [Serializable]
    public sealed class AddressOf : UnaryArithmeticOperation
    {
        /// <summary>
        /// Creates a new instance of Tril.Codoms.AddressOf
        /// </summary>
        /// <param name="operand"></param>
        public AddressOf(ValueStatement operand)
            : base(operand)
        {
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            AddressOf clone = new AddressOf(Operand);
            clone = (AddressOf)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind() 
        {
            Kind operandKind = Operand.GetKind();

            //special condition (see Partion III, pages 125 and 129)
            if (Operand is FieldRef && operandKind.IsNativeInt) 
            {
                //return operandKind;
                if (nativeIntDef == null)
                    init_nativeIntDef();
                return Kind.GetCachedKind(nativeIntDef);
            }
            
            TypeReference operandType = operandKind.UnderlyingType;
            TypeReference pointerToOperandType = operandType.MakePointerType();
            return Kind.GetCachedKind(pointerToOperandType);
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                    return (ShowOuterBrackets ? "(" : "") + "&" + Operand.ToString(translator) + (ShowOuterBrackets ? ")" : "");
                return "&" + Operand.ToString(translator) + ";";
            }
        }
    }

    /// <summary>
    /// Represents a bitwise NOT
    /// </summary>
    [Serializable]
    public sealed class BitNot : UnaryArithmeticOperation
    {
        /// <summary>
        /// Creates a new instance of Tril.Codoms.BitNot
        /// </summary>
        /// <param name="operand"></param>
        public BitNot(ValueStatement operand)
            : base(operand)
        { }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            BitNot clone = new BitNot(Operand);
            clone = (BitNot)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            return Operand.GetKind();
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                    return (ShowOuterBrackets ? "(" : "") + "~" + Operand.ToString(translator) + (ShowOuterBrackets ? ")" : "");
                return "~" + Operand.ToString(translator) + ";";
            }
        }
    }

    /// <summary>
    /// Represents a checked operation.
    /// In CIL, there are no checked blocks, just checked expressions/operations, I think.
    /// </summary>
    [Serializable]
    public sealed class Checked : UnaryArithmeticOperation
    {
        /// <summary>
        /// Creates a new instance of Tril.Checked
        /// </summary>
        /// <param name="operand"></param>
        public Checked(ValueStatement operand)
            : base(operand)
        {
            Operand.ShowOuterBrackets = false;
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            Checked clone = new Checked(Operand);
            clone = (Checked)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            return Operand.GetKind();
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                    return (ShowOuterBrackets ? "(" : "") + "checked(" + Operand.ToString(translator) + ")" + (ShowOuterBrackets ? ")" : "");
                return "checked(" + Operand.ToString(translator) + ");";
            }
        }
    }

    /// <summary>
    /// Represents a convertion operation
    /// </summary>
    [Serializable]
    public sealed class DataConversion : UnaryArithmeticOperation
    {
        Conversions _conv;

        /// <summary>
        /// Creates a new instance of Tril.Codoms.DataConversion
        /// </summary>
        /// <param name="operand"></param>
        /// <param name="conversion"></param>
        public DataConversion(ValueStatement operand, Conversions conversion)
            : base(operand)
        {
            _conv = conversion;
        }

        /// <summary>
        /// Gets the conversion to be performed
        /// </summary>
        public Conversions Conversion
        {
            get { return _conv; }
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            DataConversion clone = new DataConversion(Operand, Conversion);
            clone = (DataConversion)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            if (intDef == null)
                init_intDef();
            if (longDef == null)
                init_longDef();
            if (dblDef == null)
                init_dblDef();
            if (nativeIntDef == null)
                init_nativeIntDef();

            switch (Conversion)
            {
                case Conversions.ToInt8:
                    return Kind.GetCachedKind(intDef);//"sbyte";
                case Conversions.ToInt16:
                    return Kind.GetCachedKind(intDef);//"short";
                case Conversions.ToInt32:
                    return Kind.GetCachedKind(intDef);
                case Conversions.ToInt64:
                    return Kind.GetCachedKind(longDef);
                case Conversions.ToFloat32:
                    return Kind.GetCachedKind(dblDef);//"float";
                case Conversions.ToFloat64:
                    return Kind.GetCachedKind(dblDef);
                case Conversions.ToUInt8:
                    return Kind.GetCachedKind(intDef);//"byte";
                case Conversions.ToUInt16:
                    return Kind.GetCachedKind(intDef);//"ushort";
                case Conversions.ToUInt32:
                    return Kind.GetCachedKind(intDef);//"uint";
                case Conversions.ToUInt64:
                    return Kind.GetCachedKind(longDef);//"ulong";
                case Conversions.ToNativeInt:
                    return Kind.GetCachedKind(nativeIntDef);//native int
                case Conversions.ToUNativeInt:
                    return Kind.GetCachedKind(nativeIntDef);//"unsigned native int";
                case Conversions.ToFloatingPoint:
                    return Kind.GetCachedKind(dblDef); //floating point (probably native, probably float128)
            }
            throw new Exception(this.GetType().FullName + ": Kind could not be resolved!");
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                string conv = "";

                switch (Conversion)
                {
                    case Conversions.ToInt8:
                        conv = "int";//new int().GetType().FullName;//"sbyte";
                        break;
                    case Conversions.ToInt16:
                        conv = "int";//new int().GetType().FullName;//"short";
                        break;
                    case Conversions.ToInt32:
                        conv = "int";//new int().GetType().FullName;
                        break;
                    case Conversions.ToInt64:
                        conv = "long";//new long().GetType().FullName;
                        break;
                    case Conversions.ToFloat32:
                        conv = "double";//new double().GetType().FullName;//"float";
                        break;
                    case Conversions.ToFloat64:
                        conv = "double";//new double().GetType().FullName;
                        break;
                    case Conversions.ToUInt8:
                        conv = "int";//new int().GetType().FullName;//"byte";
                        break;
                    case Conversions.ToUInt16:
                        conv = "int";//new int().GetType().FullName;//"ushort";
                        break;
                    case Conversions.ToUInt32:
                        conv = "int";//new int().GetType().FullName;//"uint";
                        break;
                    case Conversions.ToUInt64:
                        conv = "long";//new long().GetType().FullName;//"ulong";
                        break;
                    case Conversions.ToNativeInt:
                        conv = "int";//new int().GetType().FullName;//native int
                        break;
                    case Conversions.ToUNativeInt:
                        conv = "int";//new int().GetType().FullName;//"unsigned native int";
                        break;
                    case Conversions.ToFloatingPoint:
                        conv = "double";//new double().GetType().FullName; //floating point (probably native float, probably float128)
                        break;
                }
                
                if (IsInline)
                    return (ShowOuterBrackets ? "(" : "") + "(" + conv + ")" + Operand.ToString(translator) + (ShowOuterBrackets ? ")" : "");
                return "(" + conv + ")" + Operand.ToString(translator) + ";";
            }
        }

        /// <summary>
        /// posssible conversions
        /// </summary>
        public enum Conversions
        {
            /// <summary>
            /// (signed) byte
            /// </summary>
            ToInt8,
            /// <summary>
            /// (signed) short
            /// </summary>
            ToInt16,
            /// <summary>
            /// (signed) int
            /// </summary>
            ToInt32,
            /// <summary>
            /// (signed) long
            /// </summary>
            ToInt64,
            /// <summary>
            /// float/single
            /// </summary>
            ToFloat32,
            /// <summary>
            /// double
            /// </summary>
            ToFloat64,
            /// <summary>
            /// (unsigned) byte
            /// </summary>
            ToUInt8,
            /// <summary>
            /// (unsigned) short
            /// </summary>
            ToUInt16,
            /// <summary>
            /// (unsigned) int
            /// </summary>
            ToUInt32,
            /// <summary>
            /// (unsigned) long
            /// </summary>
            ToUInt64,
            /// <summary>
            /// (signed) native int
            /// </summary>
            ToNativeInt,
            /// <summary>
            /// (unsigned) native int
            /// </summary>
            ToUNativeInt,
            /// <summary>
            /// floating point
            /// </summary>
            ToFloatingPoint
        }
    }

    /// <summary>
    /// Represents a "length of array" operation.
    /// </summary>
    [Serializable]
    public sealed class LengthOf : UnaryArithmeticOperation
    {
        /// <summary>
        /// Creates a new instance of Tril.Codoms.LengthOf
        /// </summary>
        /// <param name="operand"></param>
        public LengthOf(ValueStatement operand)
            : base(operand)
        {
            Operand.ShowOuterBrackets = false;
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            LengthOf clone = new LengthOf(Operand);
            clone = (LengthOf)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            if (nativeUIntDef == null)
                init_nativeUIntDef();
            return Kind.GetCachedKind(nativeUIntDef);
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                    return (ShowOuterBrackets ? "(" : "") + Operand.ToString(translator) + ".Length" + (ShowOuterBrackets ? ")" : "");
                return Operand.ToString(translator) + ".Length;";
            }
        }
    }

    /// <summary>
    /// Represents a "localloc" operation.
    /// This is useful in languages that support pointers.
    /// </summary>
    [Serializable]
    public sealed class LocAlloc : UnaryArithmeticOperation
    {
        /// <summary>
        /// Creates a new instance of Tril.Codoms.LocAlloc
        /// </summary>
        /// <param name="operand"></param>
        public LocAlloc(ValueStatement operand)
            : base(operand)
        {
            operand.ShowOuterBrackets = false;
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            LocAlloc clone = new LocAlloc(Operand);
            clone = (LocAlloc)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind() 
        {
            if (nativeIntDef == null)
                init_nativeIntDef();
            return Kind.GetCachedKind(nativeIntDef); //a native int 
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                    return (ShowOuterBrackets ? "(" : "") + "stackalloc " + Operand.ToString(translator) + (ShowOuterBrackets ? ")" : "");
                return "stackalloc " + Operand.ToString(translator) + ";";
            }
        }
    }

    /// <summary>
    /// Represents a negate operation
    /// </summary>
    [Serializable]
    public sealed class Neg : UnaryArithmeticOperation
    {
        /// <summary>
        /// Creates a new instance of Tril.Codoms.Neg
        /// </summary>
        /// <param name="operand"></param>
        public Neg(ValueStatement operand)
            : base(operand)
        { }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            Neg clone = new Neg(Operand);
            clone = (Neg)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            return Operand.GetKind();
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                    return (ShowOuterBrackets ? "(" : "") + "-" + Operand.ToString(translator) + (ShowOuterBrackets ? ")" : "");
                return "-" + Operand.ToString(translator) + ";";
            }
        }
    }

    /// <summary>
    /// Represents a size of operation.
    /// </summary>
    [Serializable]
    public sealed class SizeOf : UnaryArithmeticOperation
    {
        /// <summary>
        /// Creates a new instance of Tril.Codoms.SizeOf
        /// </summary>
        /// <param name="operand"></param>
        public SizeOf(TypeToken operand)
            : base(operand)
        {
            operand.ShowOuterBrackets = false;
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            SizeOf clone = new SizeOf(Operand as TypeToken);
            clone = (SizeOf)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            if (intDef == null)
                init_intDef();
            return Kind.GetCachedKind(intDef);
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                    return (ShowOuterBrackets ? "(" : "") + "sizeof(" + Operand.ToString(translator) + ")" + (ShowOuterBrackets ? ")" : "");
                return "sizeof(" + Operand.ToString(translator) + ");";
            }
        }
    }

    ///// <summary>
    ///// Represents an "object reference of" operation.
    ///// This is useful in languages that support pointers.
    ///// </summary>
    //[Serializable]
    //public sealed class ReferenceObjectOf : UnaryArithmeticOperation
    //{
    //    /// <summary>
    //    /// Creates a new instance of Tril.ReferenceOf
    //    /// </summary>
    //    /// <param name="operand"></param>
    //    public ReferenceObjectOf(ValueStatement operand)
    //        : base(operand)
    //    {
    //        Operand.ShowOuterBrackets = false;
    //    }

    //    /// <summary>
    //    /// Clones this statement
    //    /// </summary>
    //    /// <returns></returns>
    //    public override ValueStatement Clone()
    //    {
    //        ReferenceObjectOf clone = new ReferenceObjectOf(Operand);
    //        clone.IsInline = IsInline;
    //        clone.Label = ""; //clones should have no labels, but can have their labels set to that of the instruction that invoked this method
    //        return clone;
    //    }
    //    /// <summary>
    //    /// gets the C# representation of this code
    //    /// </summary>
    //    /// <returns></returns>
    //    public override string ToString()
    //    {
    //        if (IsInline)
    //            return (ShowOuterBrackets ? "(" : "") + Operand.ToString() + (ShowOuterBrackets ? ")" : "");
    //        return Operand.ToString() + ";";
    //    }
    //}
}
