using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Mono.Cecil;

using Tril.Attributes;
using Tril.Delegates;
using Tril.Models;

namespace Tril.Codoms
{
    /// <summary>
    /// Represents a statement that references a particular element in an array.
    /// </summary>
    [Serializable]
    public sealed class ArrayElement : ReferenceStatement
    {
        ValueStatement _array;
        ValueStatement[] _args;

        /// <summary>
        /// Creates a new instance of Tril.Codoms.ArrayElement
        /// </summary>
        /// <param name="cachedName"></param>
        /// <param name="cachedKind"></param>
        /// <param name="array"></param>
        /// <param name="arguments"></param>
        public ArrayElement(string cachedName, string cachedKind, ValueStatement array, params ValueStatement[] arguments)
            : base(cachedName, cachedKind)
        {
            if (array == null)
                throw new NullReferenceException(this.GetType().FullName + ": Array cannot be null!");

            _array = array;
            this.Label = array.Label;

            _args = arguments == null ? new ValueStatement[] { } : arguments;
            for (int index = 0; index < _args.Length; index++)
            {
                _args[index].IsInline = true;
                _args[index].ShowOuterBrackets = false;
            }

            IsInline = true;
        }

        /// <summary>
        /// Gets the arguments supplied
        /// </summary>
        public ValueStatement[] Arguments
        {
            get { return _args; }
        }
        /// <summary>
        /// Gets the construct that owns this indexer
        /// </summary>
        public ValueStatement Array
        {
            get { return _array; }
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            ArrayElement clone = new ArrayElement(CachedName, CachedKind, Array, Arguments);
            clone = (ArrayElement)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            TypeReference elementType = Array.GetKind().UnderlyingType.GetElementType();
            if (elementType.FullName == "System.SByte" || elementType.FullName == "System.Int16"
                || elementType.FullName == "System.Byte" || elementType.FullName == "System.UInt16"
                || elementType.FullName == "System.UInt32")
            {
                if (intDef == null)
                    init_intDef();
                return Kind.GetCachedKind(intDef);
            }
            else if (elementType.FullName == "System.UInt64")
            {
                if (longDef == null)
                    init_longDef();
                return Kind.GetCachedKind(longDef);
            }
            else if (elementType.FullName == "System.Single")
            {
                if (dblDef == null)
                    init_dblDef();
                return Kind.GetCachedKind(dblDef);
            }
            else
                return Kind.GetCachedKind(elementType);
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                string argumentSection = "";
                if (Arguments != null)
                    foreach (var argument in Arguments)
                    {
                        //if (argument != null)
                        argumentSection += argument.ToString(translator) + ", ";
                        //else
                        //    argumentSection += "null, ";
                    }
                argumentSection = argumentSection.TrimEnd(' ').TrimEnd(',');

                if (IsInline)
                {
                    return /*CachedName*/Array.ToString(translator) + "[" + argumentSection + "]";
                }
                return /*CachedName*/Array.ToString(translator) + "[" + argumentSection + "];";
            }
        }
    }

    /// <summary>
    /// Represents a statement that initializes an array object.
    /// Array object initializer is an inline code by default.
    /// </summary>
    [Serializable]
    public sealed class ArrayObjInit : ReferenceStatement
    {
        ValueStatement _numEle;
        Kind _elementKind;

        /// <summary>
        /// Creates a new instance of Tril.Codoms.ArrayObjInit
        /// </summary>
        /// <param name="cachedElementKind"></param>
        /// <param name="numOfElements"></param>
        /// <param name="arrayElementKind"></param>
        public ArrayObjInit(string cachedElementKind, ValueStatement numOfElements, Kind arrayElementKind)
            : base(cachedElementKind, cachedElementKind)
        {
            if (numOfElements == null)
                throw new NullReferenceException(this.GetType().FullName + ": Array rank cannot be null!");
            if (arrayElementKind == null)
                throw new NullReferenceException(this.GetType().FullName + ": Array element kind cannot be null!");

            this.Label = numOfElements.Label;
            _numEle = numOfElements;
            _numEle.IsInline = true;
            _elementKind = arrayElementKind;
            IsInline = true;
        }

        /// <summary>
        /// Gets the number of array elements.
        /// </summary>
        public ValueStatement NumberOfElements
        {
            get { return _numEle; }
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            ArrayObjInit clone = new ArrayObjInit(CachedKind, NumberOfElements, GetKind());
            clone = (ArrayObjInit)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            TypeReference arrayType = _elementKind.UnderlyingType.MakeArrayType();
            Kind arrayKind = Kind.GetCachedKind(arrayType);
            return arrayKind;
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                    return "new " + CachedKind + "[" + NumberOfElements.ToString(translator) + "]";
                return "new " + CachedKind + "[" + NumberOfElements.ToString(translator) + "];";
            }
        }
    }

    /// <summary>
    /// Represents a statement that references a method "base" parameter.
    /// In Java, this is the "super" parameter.
    /// </summary>
    [Serializable]
    public sealed class BaseParamRef : ReferenceStatement
    {
        Kind _thisKind;
        /// <summary>
        /// Creates a new instance of Tril.Codoms.BaseParamRef
        /// </summary>
        /// <param name="cachedKind"></param>
        /// <param name="thisKind"></param>
        public BaseParamRef(string cachedKind, Kind thisKind)
            : base("base", cachedKind)
        {
            if (thisKind == null)
                throw new NullReferenceException(this.GetType().FullName + ": The kind of a \"base\" reference cannot be null!");
            _thisKind = thisKind;
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            BaseParamRef clone = new BaseParamRef(CachedKind, GetKind());
            clone = (BaseParamRef)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            return _thisKind;
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                    return CachedName;
                return CachedName + ";";
            }
        }
    }

    /// <summary>
    /// Represents a statement that gets the default value for a type.
    /// </summary>
    [Serializable]
    public sealed class Default : ReferenceStatement
    {
        Kind _thisKind;
        /// <summary>
        /// Creates a new instance of Tril.Codoms.Default
        /// </summary>
        /// <param name="cachedKind"></param>
        /// <param name="thisKind"></param>
        public Default(string cachedKind, Kind thisKind)
            : base("default", cachedKind)
        {
            if (thisKind == null)
                throw new NullReferenceException(this.GetType().FullName + ": The kind of a \"default\" reference cannot be null!");
            _thisKind = thisKind;
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            Default clone = new Default(CachedKind, GetKind());
            clone = (Default)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            return _thisKind;
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                    return /*CachedName +*/ "default(" + CachedKind + ")";
                return /*CachedName +*/ "default(" + CachedKind + ");";
            }
        }
    }

    /// <summary>
    /// Represents a statement that references an object that
    /// was dynamically created (usually by a catch block, or as the "dummy owner" of an instance constructor).
    /// </summary>
    [Serializable]
    public class DynamicObjRef : ReferenceStatement
    {
        Kind _dynKind;

        /// <summary>
        /// Creates a new instance of Tril.Codoms.DynamicObjRef
        /// </summary>
        /// <param name="cachedName"></param>
        /// <param name="cachedKind"></param>
        /// <param name="dynamicKind"></param>
        public DynamicObjRef(string cachedName, string cachedKind, Kind dynamicKind)
            : base(cachedName, cachedKind)
        {
            if (dynamicKind == null)
                throw new NullReferenceException(this.GetType().FullName + ": Kind of dynamic object cannot be null!");
            _dynKind = dynamicKind;
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            DynamicObjRef clone = new DynamicObjRef(CachedName, CachedKind, GetKind());
            clone = (DynamicObjRef)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            return _dynKind;
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                    return CachedName;
                return CachedName + ";";
            }
        }
    }

    /// <summary>
    /// Represents a statement that references an instance field (a class-level variable)
    /// </summary>
    [Serializable]
    public sealed class InstanceFieldRef : FieldRef
    {
        ValueStatement _owner;

        /// <summary>
        /// Creates a new instance of Tril.Codoms.FieldRef
        /// </summary>
        /// <param name="cachedFieldName"></param>
        /// <param name="cachedDecKind"></param>
        /// <param name="owner"></param>
        /// <param name="refedField"></param>
        public InstanceFieldRef(string cachedFieldName, string cachedDecKind, ValueStatement owner, Field refedField)
            : base(cachedFieldName, cachedDecKind, refedField)
        {
            if (owner == null)
                throw new NullReferenceException(this.GetType().FullName + ": Instance field owner object cannot be null!");

            if (owner is ThisParamRef)
                UseShortName = true;
            _owner = owner;
            this.Label = owner.Label;
        }

        /// <summary>
        /// Gets the construct that references the field
        /// </summary>
        public ValueStatement Owner
        {
            get { return _owner; }
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            InstanceFieldRef clone = new InstanceFieldRef(CachedName, CachedKind, Owner, ReferencedField);
            clone = (InstanceFieldRef)ValueStatement.Clone(this, clone);
            clone.UseShortName = UseShortName;
            return clone;
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                {
                    if (UseShortName)
                        return CachedName;
                    return Owner.ToString(translator) + "." + CachedName;
                }
                if (UseShortName)
                    return CachedName + ";";
                return Owner.ToString(translator) + "." + CachedName + ";";
            }
        }
    }

    /// <summary>
    /// Represents a statement that references an instance method
    /// </summary>
    [Serializable]
    public sealed class InstanceMethodRef : MethodRef
    {
        ValueStatement _owner;
        bool _isBaseMethodCall;
        bool _isExplicitCall;

        /// <summary>
        /// Creates a new instance of Tril.Codoms.InstanceMethodRef
        /// </summary>
        /// <param name="cachedMethodName"></param>
        /// <param name="cachedDeclaringKind"></param>
        /// <param name="isBaseMethodCall"></param>
        /// <param name="isExplicitConstructorCall"></param>
        /// <param name="owner"></param>
        /// <param name="refedMethod"></param>
        /// <param name="arguments"></param>
        public InstanceMethodRef(string cachedMethodName, string cachedDeclaringKind, bool isBaseMethodCall, bool isExplicitConstructorCall,
            ValueStatement owner, Method refedMethod, params ValueStatement[] arguments)
            : base(cachedMethodName, cachedDeclaringKind, refedMethod, arguments)
        {
            if (owner == null)
                throw new NullReferenceException(this.GetType().FullName + ": Instance method owner object cannot be null!");

            if (owner is ThisParamRef)
            {
                if (isBaseMethodCall) //change "this" to "base" and use long name
                {
                    ThisParamRef formerOwner = (owner as ThisParamRef);
                    owner = new BaseParamRef(formerOwner.CachedKind, formerOwner.GetKind()) { Label = formerOwner.Label };
                    //UseShortName = false;
                }
                else
                    UseShortName = true; ;
            }

            _isBaseMethodCall = IsBaseMethodCall;
            _isExplicitCall = isExplicitConstructorCall;

            _owner = owner;
            this.Label = owner.Label;

            if (CachedKind.ToLower().Contains("void") || CachedKind.ToLower().Contains("null"))
                IsInline = false;
            else
                IsInline = true;
        }

        /// <summary>
        /// Gets a value to determine if the referenced method actually belongs to a base (super) class of the calling object.
        /// </summary>
        public bool IsBaseMethodCall
        {
            get { return _isBaseMethodCall; }
        }
        /// <summary>
        /// Gets a value to determine if the referenced method is a constructor and was called explicitly
        /// using a CIL call instruction, as against using a newobj instruction.
        /// </summary>
        public bool IsExplicitConstructorCall
        {
            get { return _isExplicitCall; }
        }
        /// <summary>
        /// Gets the construct that references the method
        /// </summary>
        public ValueStatement Owner
        {
            get { return _owner; }
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            InstanceMethodRef clone = new InstanceMethodRef(CachedName, CachedKind, IsBaseMethodCall, IsExplicitConstructorCall, Owner, ReferencedMethod, Arguments);
            clone = (InstanceMethodRef)ValueStatement.Clone(this, clone);
            clone.UseShortName = UseShortName;
            return clone;
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                string argumentSection = "";
                foreach (var argument in Arguments)
                {
                    //if (argument != null)
                    argumentSection += argument.ToString(translator) + ", ";
                    //else
                    //    argumentSection += "null, ";
                }
                argumentSection = argumentSection.TrimEnd(' ').TrimEnd(',');

                if (IsExplicitConstructorCall)
                {
                    if (IsInline)
                    {
                        return Owner.ToString(translator) + "(" + argumentSection + ")";
                    }
                    return Owner.ToString(translator) + "(" + argumentSection + ");";
                }
                else
                {
                    string newStr = "";
                    if (ReferencedMethod.IsConstructor)
                        newStr = "new ";

                    if (IsInline)
                    {
                        if (UseShortName)
                            return newStr + CachedName + "(" + argumentSection + ")";
                        return newStr + Owner.ToString(translator) + "." + CachedName + "(" + argumentSection + ")";
                    }
                    if (UseShortName)
                        return newStr + CachedName + "(" + argumentSection + ");";
                    return newStr + Owner.ToString(translator) + "." + CachedName + "(" + argumentSection + ");";
                }
            }
        }
    }

    /// <summary>
    /// Represents a "ldftn" instruction.
    /// This is useful in languages that support pointers.
    /// </summary>
    [Serializable]
    public sealed class MethodFunction : ReferenceStatement
    {
        Method _refedMethod;

        /// <summary>
        /// Creates a new instance of Tril.Codoms.MethodFunction
        /// </summary>
        /// <param name="cachedMethodName"></param>
        /// <param name="cachedDeclaringKind"></param>
        /// <param name="refedMethod"></param>
        public MethodFunction(string cachedMethodName, string cachedDeclaringKind, Method refedMethod)
            : base(cachedMethodName, cachedDeclaringKind)
        {
            if (refedMethod == null)
                throw new NullReferenceException(this.GetType().FullName + ": Referenced method cannot be null!");

            _refedMethod = refedMethod;
        }

        /// <summary>
        /// Gets the referenced method.
        /// </summary>
        public Method ReferencedMethod
        {
            get { return _refedMethod; }
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            MethodFunction clone = new MethodFunction(CachedName, CachedKind, ReferencedMethod);
            clone = (MethodFunction)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            if (nativeIntDef == null)
                init_nativeIntDef();
            return Kind.GetCachedKind(nativeIntDef); //a native int
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                {
                    if (UseShortName)
                        return CachedName;
                    return CachedKind + "." + CachedName;
                }
                if (UseShortName)
                    return CachedName + ";";
                return CachedKind + "." + CachedName + ";";
            }
        }
    }

    /// <summary>
    /// Represents a "ldvirtftn" instruction.
    /// This is useful in languages that support pointers.
    /// </summary>
    [Serializable]
    public sealed class MethodVirtualFunction : ReferenceStatement //********what if the refed method is a constructor
    {
        ValueStatement _owner;
        Method _refedMethod;

        /// <summary>
        /// Creates a new instance of Tril.Codoms.MethodVirtualFunction
        /// </summary>
        /// <param name="cachedMethodName"></param>
        /// <param name="cachedDeclaringKind"></param>
        /// <param name="owner"></param>
        /// <param name="refedMethod"></param>
        public MethodVirtualFunction(string cachedMethodName, string cachedDeclaringKind, ValueStatement owner, Method refedMethod)
            : base(cachedMethodName, cachedDeclaringKind)
        {
            if (owner == null)
                throw new NullReferenceException(this.GetType().FullName + ": Instance method owner object cannot be null!");
            //if (owner is ThisParamRef)
            //    UseShortName = true;

            if (refedMethod == null)
                throw new NullReferenceException(this.GetType().FullName + ": Referenced method cannot be null!");

            _owner = owner;
            this.Label = owner.Label;
            _refedMethod = refedMethod;
        }

        /// <summary>
        /// Gets the construct that references the method
        /// </summary>
        public ValueStatement Owner
        {
            get { return _owner; }
        }
        /// <summary>
        /// Gets the referenced method.
        /// </summary>
        public Method ReferencedMethod
        {
            get { return _refedMethod; }
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            MethodVirtualFunction clone = new MethodVirtualFunction(CachedName, CachedKind, Owner, ReferencedMethod);
            clone = (MethodVirtualFunction)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind() 
        {
            if (nativeIntDef == null)
                init_nativeIntDef();
            return Kind.GetCachedKind(nativeIntDef); //a native int
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                {
                    if (UseShortName)
                        return CachedName;
                    //return Owner.ToString(translator) + "." + CachedName;
                    return CachedKind + "." + CachedName;
                }
                if (UseShortName)
                    return CachedName + ";";
                //return Owner.ToString(translator) + "." + CachedName + ";";
                return CachedKind + "." + CachedName + ";";
            }
        }
    }

    /// <summary>
    /// Represents a statement that references a method parameter.
    /// </summary>
    [Serializable]
    public sealed class ParamRef : ReferenceStatement 
    {
        Parameter _refedParam;

        /// <summary>
        /// Creates a new instance of Tril.Codoms.ParamRef
        /// </summary>
        /// <param name="cachedName"></param>
        /// <param name="cachedKind"></param>
        /// <param name="refedParam"></param>
        public ParamRef(string cachedName, string cachedKind, Parameter refedParam)
            : base(cachedName, cachedKind)
        {
            if (refedParam == null)
                throw new NullReferenceException(this.GetType().FullName + ": Referenced parameter cannot be null!");
            _refedParam = refedParam;
        }

        /// <summary>
        /// Gets the referenced parameter.
        /// </summary>
        public Parameter ReferencedParameter
        {
            get { return _refedParam; }
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            ParamRef clone = new ParamRef(CachedName, CachedKind, ReferencedParameter);
            clone = (ParamRef)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            return ReferencedParameter.GetParameterKind(true); //use default only
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator) //******************handle ref and out parameters
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                    return CachedName;
                return CachedName + ";";
            }
        }
    }

    /// <summary>
    /// Represents a reference to a pointer element.
    /// This is useful for languages that support pointers.
    /// </summary>
    [Serializable]
    public sealed class PointerElement : ReferenceStatement
    {
        ValueStatement _pointer;

        /// <summary>
        /// Creates a new instance of Tril.Codoms.PointerElement
        /// </summary>
        /// <param name="cachedName"></param>
        /// <param name="cachedKind"></param>
        /// <param name="pointer"></param>
        public PointerElement(string cachedName, string cachedKind, ValueStatement pointer)
            : base(cachedName, cachedKind)
        {
            if (pointer == null)
                throw new NullReferenceException(this.GetType().FullName + ": Pointer cannot be null!");

            _pointer = pointer;
            this.Label = pointer.Label;

            IsInline = true;
        }

        /// <summary>
        /// Gets the pointer
        /// </summary>
        public ValueStatement Pointer
        {
            get { return _pointer; }
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            PointerElement clone = new PointerElement(CachedName, CachedKind, Pointer);
            clone = (PointerElement)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            TypeReference elementType = Pointer.GetKind().UnderlyingType.GetElementType();
            if (elementType.FullName == "System.SByte" || elementType.FullName == "System.Int16"
                || elementType.FullName == "System.Byte" || elementType.FullName == "System.UInt16"
                || elementType.FullName == "System.UInt32")
            {
                if (intDef == null)
                    init_intDef();
                return Kind.GetCachedKind(intDef);
            }
            else if (elementType.FullName == "System.UInt64")
            {
                if (longDef == null)
                    init_longDef();
                return Kind.GetCachedKind(longDef);
            }
            else if (elementType.FullName == "System.Single")
            {
                if (dblDef == null)
                    init_dblDef();
                return Kind.GetCachedKind(dblDef);
            }
            else
                return Kind.GetCachedKind(elementType);
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                {
                    return (ShowOuterBrackets ? "(" : "") + "*" + /*CachedName*/Pointer.ToString(translator) + (ShowOuterBrackets ? ")" : "");
                }
                return "*" + /*CachedName*/Pointer.ToString(translator) + ";";
            }
        }
    }

    /// <summary>
    /// Represents a statement that references a static field (a class-level variable)
    /// </summary>
    [Serializable]
    public sealed class StaticFieldRef : FieldRef
    {

        /// <summary>
        /// Creates a new instance of Tril.Codoms.StaticFieldRef
        /// </summary>
        /// <param name="cachedFieldName"></param>
        /// <param name="cachedDecKind"></param>
        /// <param name="refedField"></param>
        public StaticFieldRef(string cachedFieldName, string cachedDecKind, Field refedField)
            : base(cachedFieldName, cachedDecKind, refedField)
        {
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            StaticFieldRef clone = new StaticFieldRef(CachedName, CachedKind, ReferencedField);
            clone = (StaticFieldRef)ValueStatement.Clone(this, clone);
            clone.UseShortName = UseShortName;
            return clone;
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                {
                    if (UseShortName)
                        return CachedName;
                    return CachedKind + "." + CachedName;
                }
                if (UseShortName)
                    return CachedName + ";";
                return CachedKind + "." + CachedName + ";";
            }
        }
    }

    /// <summary>
    /// Represents a statement that references a static method
    /// </summary>
    [Serializable]
    public sealed class StaticMethodRef : MethodRef
    {
        /// <summary>
        /// Creates a new instance of Tril.Codoms.StaticMethodRef
        /// </summary>
        /// <param name="cachedMethodName"></param>
        /// <param name="cachedDecKind"></param>
        /// <param name="refedMethod"></param>
        /// <param name="arguments"></param>
        public StaticMethodRef(string cachedMethodName, string cachedDecKind, Method refedMethod, params ValueStatement[] arguments)
            : base(cachedMethodName, cachedDecKind, refedMethod, arguments)
        {
            if (CachedKind.ToLower().Contains("void") || CachedKind.ToLower().Contains("null"))
                IsInline = false;
            else
                IsInline = true;

            if (Arguments != null)
                if (Arguments.Length > 0)
                    if (Arguments[0] != null)
                        this.Label = Arguments[0].Label;
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            StaticMethodRef clone = new StaticMethodRef(CachedName, CachedKind, ReferencedMethod, Arguments);
            clone = (StaticMethodRef)ValueStatement.Clone(this, clone);
            clone.UseShortName = UseShortName;
            return clone;
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                string newStr = "";
                if (ReferencedMethod != null)
                    if (ReferencedMethod.IsConstructor)
                        newStr = "new ";

                string argumentSection = "";
                if (Arguments != null)
                    foreach (var argument in Arguments)
                    {
                        //if (argument != null)
                        argumentSection += argument.ToString(translator) + ", ";
                        //else
                        //    argumentSection += "null, ";
                    }
                argumentSection = argumentSection.TrimEnd(' ').TrimEnd(',');

                if (IsInline)
                {
                    if (UseShortName)
                        return newStr + CachedName + "(" + argumentSection + ")";
                    return newStr + CachedKind + "." + CachedName + "(" + argumentSection + ")";
                }
                if (UseShortName)
                    return newStr + CachedName + "(" + argumentSection + ");";
                return newStr + CachedKind + "." + CachedName + "(" + argumentSection + ");";
            }
        }
    }
    /// <summary>
    /// Represents a statement that references a method "this" parameter.
    /// In VB, this is the "Me" parameter.
    /// </summary>
    [Serializable]
    public sealed class ThisParamRef : ReferenceStatement
    {
        Kind _thisKind;
        /// <summary>
        /// Creates a new instance of Tril.Codoms.ThisParamRef
        /// </summary>
        /// <param name="cachedKind"></param>
        /// <param name="thisKind"></param>
        public ThisParamRef(string cachedKind, Kind thisKind)
            : base("this", cachedKind)
        {
            if (thisKind == null)
                throw new NullReferenceException(this.GetType().FullName + ": The kind of a \"this\" reference cannot be null!");
            _thisKind = thisKind;
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            ThisParamRef clone = new ThisParamRef(CachedKind, GetKind());
            clone = (ThisParamRef)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            return _thisKind;
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                    return CachedName;
                return CachedName + ";";
            }
        }
    }

    /// <summary>
    /// Represents a statement that references a variable.
    /// </summary>
    [Serializable]
    public sealed class VarRef : ReferenceStatement
    {
        Variable _refedVar;

        /// <summary>
        /// Creates a new instance of Tril.Codoms.VarRef
        /// </summary>
        /// <param name="cachedName"></param>
        /// <param name="cachedKind"></param>
        /// <param name="refedVariable"></param>
        public VarRef(string cachedName, string cachedKind, Variable refedVariable)
            : base(cachedName, cachedKind)
        {
            if (refedVariable == null)
                throw new NullReferenceException(this.GetType().FullName + ": Referenced variable cannot be null!");
            _refedVar = refedVariable;
        }

        /// <summary>
        /// Gets the referenced variable.
        /// </summary>
        public Variable ReferencedVariable
        {
            get { return _refedVar; }
        }

        /// <summary>
        /// Clones this statement
        /// </summary>
        /// <returns></returns>
        public override ValueStatement Clone()
        {
            VarRef clone = new VarRef(CachedName, CachedKind, ReferencedVariable);
            clone = (VarRef)ValueStatement.Clone(this, clone);
            return clone;
        }
        /// <summary>
        /// Gets the Kind of this code.
        /// </summary>
        /// <returns></returns>
        public override Kind GetKind()
        {
            return ReferencedVariable.VariableKind;
        }
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                if (IsInline)
                    return CachedName;
                return CachedName + ";";
            }
        }
    }
}
