using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Mono.Cecil;

using Tril.Attributes;
using Tril.Delegates;
using Tril.Models;

namespace Tril.Codoms
{
    /// <summary>
    /// Represents a try block
    /// </summary>
    [Serializable]
    public sealed class Try : Block
    {
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                string codeString = "";
                codeString += "try {\n";
                foreach (Codom tryBodyCode in this)
                {
                    codeString += tryBodyCode.ToString(translator) + "\n";
                }
                codeString += "}"; //always put braces around blocks
                return codeString;
            }
        }
    }

    /// <summary>
    /// Represents a catch block
    /// </summary>
    [Serializable]
    public sealed class Catch : Block
    {
        Kind _caughtExKind;
        DynamicObjRef _caughtExObj;
        string _cachedCaughtExKind;
        bool _showExObj = true;

        /// <summary>
        /// Creates a new instance of Tril.Codoms.Catch
        /// </summary>
        /// <param name="cachedCaughtExceptionKind"></param>
        /// <param name="caughtExceptionKind"></param>
        /// <param name="caughtExceptionObject"></param>
        public Catch(string cachedCaughtExceptionKind, Kind caughtExceptionKind, DynamicObjRef caughtExceptionObject)
        {
            if (cachedCaughtExceptionKind == null || cachedCaughtExceptionKind.Trim() == "")
                throw new NullReferenceException(this.GetType().FullName + ": Cached exception kind cannot be null or empty!");
            if (caughtExceptionKind == null)
                throw new NullReferenceException(this.GetType().FullName + ": Exception kind cannot be null!");
            if (caughtExceptionObject == null)
                throw new NullReferenceException(this.GetType().FullName + ": Exception object cannot be null!");

            _cachedCaughtExKind = cachedCaughtExceptionKind.Trim();
            _caughtExObj = caughtExceptionObject;
            _caughtExKind = caughtExceptionKind;
        }

        /// <summary>
        /// Gets the caught exception kind cashed at the point of creating this instance.
        /// </summary>
        public string CachedCaughtExceptionKind
        {
            get { return _cachedCaughtExKind; }
        }
        /// <summary>
        /// Gets the exception object caught by this catch block.
        /// </summary>
        public DynamicObjRef CaughtExceptionObject
        {
            get { return _caughtExObj; }
            //set { _caughtExObj = value; }
        }
        /// <summary>
        /// Gets the exception kind caught by this catch block.
        /// </summary>
        public Kind CaughtExceptionKind
        {
            get { return _caughtExKind; }
        }
        /// <summary>
        /// Gets or sets a value to determine if the exception object is to be shown (in high level languages like C#).
        /// </summary>
        public bool ShowExceptionObject
        {
            get { return _showExObj; }
            set { _showExObj = value; }
        }

        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                string codeString = "";
                if (ShowExceptionObject)
                    codeString += "catch(" + CachedCaughtExceptionKind + " " + CaughtExceptionObject.ToString(translator) + ") {\n";
                else
                    codeString += "catch(" + CachedCaughtExceptionKind + ") {\n";
                foreach (Codom catchBodyCode in this)
                {
                    codeString += catchBodyCode.ToString(translator) + "\n";
                }
                codeString += "}"; //always put braces around blocks
                return codeString;
            }
        }
    }

    /// <summary>
    /// Represents a filter handler body
    /// </summary>
    [Serializable]
    public sealed class FilterHandler : Block
    {
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                string codeString = "";
                codeString += "filter handler {\n";
                foreach (Codom tryBodyCode in this)
                {
                    codeString += tryBodyCode.ToString(translator) + "\n";
                }
                codeString += "}"; //always put braces around blocks
                return codeString;
            }
        }
    }

    /// <summary>
    /// Represents a filter block
    /// </summary>
    [Serializable]
    public sealed class Filter : Block
    {
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                string codeString = "";
                codeString += "filter {\n";
                foreach (Codom tryBodyCode in this)
                {
                    codeString += tryBodyCode.ToString(translator) + "\n";
                }
                codeString += "}"; //always put braces around blocks
                return codeString;
            }
        }
    }

    /// <summary>
    /// Represents a finally block
    /// </summary>
    [Serializable]
    public sealed class Finally : Block
    {
        /// <summary>
        /// gets the C# representation of this code
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(null);
        }
        /// <summary>
        /// Returns the string representation of this code, as generated by the specified translator.
        /// </summary>
        /// <param name="translator"></param>
        /// <returns></returns>
        public override string ToString(CodomTranslator translator)
        {
            string trans = Codom.ToString(translator, this);
            if (trans != null)
                return trans;
            else
            {
                string codeString = "";
                codeString += "finally {\n";
                foreach (Codom finallyBodyCode in this)
                {
                    codeString += finallyBodyCode.ToString(translator) + "\n";
                }
                codeString += "}"; //always put braces around blocks
                return codeString;
            }
        }
    }
}
